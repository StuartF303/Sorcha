// SPDX-License-Identifier: MIT
// Copyright (c) 2025 Sorcha Contributors

syntax = "proto3";

package sorcha.peer.v1;

option csharp_namespace = "Sorcha.Peer.Service.Protos";

// Heartbeat Service
// Provides connection health monitoring between peer nodes and central nodes
// using periodic heartbeat messages.
//
// Heartbeat Protocol:
// 1. Peer sends heartbeat every 30 seconds to connected central node
// 2. Central node responds with acknowledgement within 30 seconds
// 3. If 2 consecutive heartbeats timeout (60 seconds total), peer triggers failover
//
// Heartbeat Message Contains:
// - Peer identity and sequence number
// - Last known system register version (for sync lag detection)
// - Optional health metrics (CPU, memory, active connections)
//
// Failover Logic:
// - 1 missed heartbeat (30s): Warning, continue
// - 2 missed heartbeats (60s): Trigger failover to next central node (n0 → n1 → n2)
// - All central nodes unreachable: Enter "Isolated" mode (use last known system register replica)
//
// Health Metrics:
// - Optional CPU, memory, and connection count
// - Used by central node for load balancing and monitoring
service Heartbeat {
  // Send unary heartbeat (simple request/response)
  //
  // Peer sends heartbeat to central node. Central node responds with
  // acknowledgement and current system register version.
  //
  // Timeout: 30 seconds
  // Frequency: Every 30 seconds
  // Retry: No retry (missed heartbeat triggers failover logic)
  rpc SendHeartbeat(HeartbeatMessage) returns (HeartbeatAcknowledgement);

  // Monitor heartbeat (bidirectional streaming)
  //
  // Alternative to unary heartbeat using bidirectional streaming.
  // Allows multiplexing heartbeat with other peer-to-central messages.
  //
  // Flow:
  // 1. Peer initiates stream and sends first HeartbeatMessage
  // 2. Central node responds with HeartbeatAcknowledgement
  // 3. Peer sends periodic heartbeats on same stream
  // 4. Central node responds to each heartbeat
  //
  // Advantages:
  // - Single long-lived connection
  // - Lower overhead than repeated unary calls
  // - Can multiplex with status updates
  //
  // Disadvantages:
  // - More complex stream lifecycle management
  // - Harder to debug than unary calls
  //
  // Note: Most implementations should use SendHeartbeat (unary) for simplicity
  rpc MonitorHeartbeat(stream HeartbeatMessage) returns (stream HeartbeatAcknowledgement);

  // Get heartbeat status
  //
  // Returns current heartbeat status for a peer.
  // Used for monitoring and diagnostics.
  rpc GetHeartbeatStatus(HeartbeatStatusRequest) returns (HeartbeatStatus);
}

// Heartbeat message sent from peer to central node
message HeartbeatMessage {
  // Unique identifier of peer sending heartbeat
  // Validation: Required, MaxLength 64
  string peer_id = 1;

  // Unix timestamp when heartbeat was sent (milliseconds UTC)
  // Used to detect clock skew and measure round-trip time
  // Validation: Must be within ±60 seconds of receiver's current time
  int64 timestamp = 2;

  // Monotonically increasing sequence number
  // Increments with each heartbeat from same peer
  // Used to detect missed heartbeats and out-of-order delivery
  int64 sequence_number = 3;

  // Last known system register version
  // Central node compares with current version to detect peer lag
  // If peer is behind, acknowledgement includes version hint
  int64 last_sync_version = 4;

  // Session identifier (from ConnectionResponse)
  // Links heartbeat to connection session
  string session_id = 5;

  // Type of node sending heartbeat
  // Values: "Central", "Peer"
  string node_type = 6;

  // Optional health metrics
  HealthMetrics metrics = 7;
}

// Health metrics from peer node (optional)
message HealthMetrics {
  // Number of active peer connections
  // Indicates network connectivity health
  int32 active_connections = 1;

  // CPU usage percentage (0-100)
  // Validation: Range 0-100
  double cpu_usage_percent = 2;

  // Memory usage in megabytes
  // Includes process memory, not system-wide
  double memory_usage_mb = 3;

  // Disk usage percentage (0-100)
  // Validation: Range 0-100
  double disk_usage_percent = 4;

  // Number of blueprints in local system register replica
  int32 blueprint_count = 5;

  // Number of pending sync operations
  int32 pending_syncs = 6;

  // Whether peer is currently syncing
  bool is_syncing = 7;

  // Uptime in seconds
  int64 uptime_seconds = 8;
}

// Acknowledgement response to heartbeat
message HeartbeatAcknowledgement {
  // Whether heartbeat was successfully processed
  // false indicates central node is unhealthy or overloaded
  bool success = 1;

  // Unix timestamp when acknowledgement was sent (milliseconds UTC)
  // Used to measure round-trip latency
  int64 timestamp = 2;

  // Identifier of responding central node
  // Examples: "n0.sorcha.dev", "n1.sorcha.dev", "n2.sorcha.dev"
  string central_node_id = 3;

  // Current system register version on central node
  // Peer compares with last_sync_version to detect lag
  // If peer is behind, peer triggers incremental sync
  int64 current_system_register_version = 4;

  // Optional status message
  // Examples: "OK", "Degraded", "High load"
  string message = 5;

  // Recommended action for peer (optional)
  RecommendedAction recommended_action = 6;

  // Server-side measured latency (milliseconds)
  // Time between receiving heartbeat and sending acknowledgement
  int64 server_latency_ms = 7;
}

// Recommended action from central node to peer
enum RecommendedAction {
  // No action needed, continue normal operation
  RECOMMENDED_ACTION_NONE = 0;

  // Peer should trigger incremental sync (version lag detected)
  RECOMMENDED_ACTION_SYNC = 1;

  // Peer should reduce heartbeat frequency (central node overloaded)
  RECOMMENDED_ACTION_REDUCE_FREQUENCY = 2;

  // Peer should disconnect and failover to another central node
  RECOMMENDED_ACTION_FAILOVER = 3;

  // Peer should reconnect (session invalid)
  RECOMMENDED_ACTION_RECONNECT = 4;
}

// Request for heartbeat status
message HeartbeatStatusRequest {
  // Peer identifier to get status for
  // If empty, returns status for all connected peers (central node only)
  string peer_id = 1;

  // Session identifier (optional)
  string session_id = 2;
}

// Current heartbeat status for a peer
message HeartbeatStatus {
  // Peer identifier
  string peer_id = 1;

  // Session identifier
  string session_id = 2;

  // Timestamp of last heartbeat received (Unix milliseconds UTC)
  // 0 if no heartbeat received yet
  int64 last_heartbeat_time = 3;

  // Number of consecutive missed heartbeats
  // Increments on timeout, resets on successful heartbeat
  // Threshold: 2 missed = failover trigger
  int32 missed_heartbeats = 4;

  // Whether heartbeat connection is healthy
  // Healthy = received heartbeat within last 30 seconds
  bool is_healthy = 5;

  // Human-readable status message
  string status_message = 6;

  // Total heartbeats received in this session
  int64 total_heartbeats_received = 7;

  // Total heartbeats missed in this session
  int64 total_heartbeats_missed = 8;

  // Average round-trip latency (milliseconds)
  // Calculated over last 10 heartbeats
  double average_latency_ms = 9;

  // Last known sync version from peer
  int64 last_known_sync_version = 10;

  // Version lag (current - last_known_sync_version)
  // Positive = peer is behind
  // Negative = should not happen (data integrity issue)
  int64 version_lag = 11;

  // Heartbeat health status
  HeartbeatHealthStatus health_status = 12;
}

// Health status of heartbeat connection
enum HeartbeatHealthStatus {
  // Unknown status
  HEARTBEAT_HEALTH_STATUS_UNKNOWN = 0;

  // Healthy: receiving heartbeats on time
  HEARTBEAT_HEALTH_STATUS_HEALTHY = 1;

  // Warning: 1 missed heartbeat (30s timeout)
  HEARTBEAT_HEALTH_STATUS_WARNING = 2;

  // Critical: 2 missed heartbeats (60s timeout), failover imminent
  HEARTBEAT_HEALTH_STATUS_CRITICAL = 3;

  // Timeout: no heartbeat received, connection considered failed
  HEARTBEAT_HEALTH_STATUS_TIMEOUT = 4;

  // Disconnected: peer explicitly disconnected
  HEARTBEAT_HEALTH_STATUS_DISCONNECTED = 5;
}
