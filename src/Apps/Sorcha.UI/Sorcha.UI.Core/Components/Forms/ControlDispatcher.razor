@* SPDX-License-Identifier: MIT *@
@* Copyright (c) 2026 Sorcha Contributors *@

@using System.Text.Json
@using Sorcha.Blueprint.Models
@using Sorcha.UI.Core.Models.Forms

@if (_shouldRender && !_isHidden)
{
    @switch (Control.ControlType)
    {
        case ControlTypes.Layout:
            @switch (Control.Layout)
            {
                case LayoutTypes.VerticalLayout:
                    <VerticalLayoutRenderer Control="Control" Depth="Depth" />
                    break;
                case LayoutTypes.HorizontalLayout:
                    <HorizontalLayoutRenderer Control="Control" Depth="Depth" />
                    break;
                case LayoutTypes.Group:
                    <GroupRenderer Control="Control" Depth="Depth" />
                    break;
                case LayoutTypes.Categorization:
                    <CategorizationRenderer Control="Control" Depth="Depth" />
                    break;
            }
            break;

        case ControlTypes.Label:
            <LabelRenderer Control="Control" IsDisabled="_isDisabled" />
            break;

        case ControlTypes.TextLine:
            <TextLineRenderer Control="Control" IsDisabled="_isDisabled" />
            break;

        case ControlTypes.TextArea:
            <TextAreaRenderer Control="Control" IsDisabled="_isDisabled" />
            break;

        case ControlTypes.Numeric:
            <NumericRenderer Control="Control" IsDisabled="_isDisabled" />
            break;

        case ControlTypes.DateTime:
            <DateTimeRenderer Control="Control" IsDisabled="_isDisabled" />
            break;

        case ControlTypes.Checkbox:
            <CheckboxRenderer Control="Control" IsDisabled="_isDisabled" />
            break;

        case ControlTypes.Selection:
            <SelectionRenderer Control="Control" IsDisabled="_isDisabled" />
            break;

        case ControlTypes.Choice:
            <ChoiceRenderer Control="Control" IsDisabled="_isDisabled" />
            break;

        case ControlTypes.File:
            <FileRenderer Control="Control" IsDisabled="_isDisabled" />
            break;

        default:
            <UnsupportedControlRenderer Control="Control" />
            break;
    }
}

@code {
    [CascadingParameter] public FormContext? FormContext { get; set; }
    [Parameter, EditorRequired] public Control Control { get; set; } = new();
    [Parameter] public int Depth { get; set; }

    private bool _shouldRender = true;
    private bool _isHidden;
    private bool _isDisabled;

    protected override void OnParametersSet()
    {
        EvaluateVisibility();
    }

    protected override void OnInitialized()
    {
        if (FormContext is not null)
        {
            FormContext.OnDataChanged += OnDataChanged;
        }
    }

    private void OnDataChanged()
    {
        EvaluateVisibility();
        InvokeAsync(StateHasChanged);
    }

    private void EvaluateVisibility()
    {
        _shouldRender = true;
        _isHidden = false;
        _isDisabled = false;

        if (FormContext is null) return;

        // 1. Check disclosure filter (only for controls with a scope)
        if (!string.IsNullOrEmpty(Control.Scope))
        {
            if (!FormContext.IsDisclosed(Control.Scope))
            {
                _shouldRender = false;
                return;
            }
        }

        // 2. Evaluate rule (if present)
        if (Control.Rule is not null)
        {
            var conditionMet = EvaluateCondition(Control.Rule.Condition);

            switch (Control.Rule.Effect)
            {
                case RuleEffect.SHOW:
                    _isHidden = !conditionMet;
                    _shouldRender = conditionMet;
                    break;
                case RuleEffect.HIDE:
                    _isHidden = conditionMet;
                    _shouldRender = !conditionMet;
                    break;
                case RuleEffect.ENABLE:
                    _isDisabled = !conditionMet;
                    break;
                case RuleEffect.DISABLE:
                    _isDisabled = conditionMet;
                    break;
            }
        }

        // Read-only mode disables all controls
        if (FormContext.IsReadOnly)
        {
            _isDisabled = true;
        }
    }

    private bool EvaluateCondition(SchemaBasedCondition condition)
    {
        if (FormContext is null || condition.Schema is null)
            return false;

        var scope = condition.Scope;
        if (string.IsNullOrEmpty(scope))
            return false;

        // Get the current value at the scope
        var value = FormContext.FormData.TryGetValue(scope, out var v) ? v : null;

        // Evaluate against the condition schema
        try
        {
            var schemaJson = condition.Schema.ToJsonString();
            using var schemaDoc = JsonDocument.Parse(schemaJson);
            var schemaRoot = schemaDoc.RootElement;

            // Simple const comparison
            if (schemaRoot.TryGetProperty("const", out var constVal))
            {
                return ValuesMatch(value, constVal);
            }

            // Enum check
            if (schemaRoot.TryGetProperty("enum", out var enumVal))
            {
                return enumVal.EnumerateArray().Any(e => ValuesMatch(value, e));
            }

            // Type check with not
            if (schemaRoot.TryGetProperty("not", out var notSchema))
            {
                if (notSchema.TryGetProperty("const", out var notConst))
                    return !ValuesMatch(value, notConst);
            }

            return value is not null;
        }
        catch
        {
            return false;
        }
    }

    private static bool ValuesMatch(object? value, JsonElement expected)
    {
        return expected.ValueKind switch
        {
            JsonValueKind.True => value is true || (value is string s && s.Equals("true", StringComparison.OrdinalIgnoreCase)),
            JsonValueKind.False => value is false || value is null || (value is string s && (string.IsNullOrEmpty(s) || s.Equals("false", StringComparison.OrdinalIgnoreCase))),
            JsonValueKind.String => value?.ToString() == expected.GetString(),
            JsonValueKind.Number => decimal.TryParse(value?.ToString(), out var d) && d == expected.GetDecimal(),
            JsonValueKind.Null => value is null,
            _ => false
        };
    }

    public void Dispose()
    {
        if (FormContext is not null)
        {
            FormContext.OnDataChanged -= OnDataChanged;
        }
    }
}
