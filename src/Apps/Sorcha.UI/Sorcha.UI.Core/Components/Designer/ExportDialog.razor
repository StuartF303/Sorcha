@* SPDX-License-Identifier: MIT *@
@* Copyright (c) 2025 Sorcha Contributors *@

@using MudBlazor
@using Sorcha.UI.Core.Services
@using Sorcha.Blueprint.Models
@using Microsoft.JSInterop

<MudDialog>
    <TitleContent>
        <MudText Typo="Typo.h6">
            <MudIcon Icon="@Icons.Material.Filled.FileDownload" Class="mr-2" />
            Export Blueprint
        </MudText>
    </TitleContent>
    <DialogContent>
        <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-4">
            Export "@Blueprint.Title" as a file for backup or sharing.
        </MudText>

        <MudRadioGroup T="ExportFormat" @bind-Value="SelectedFormat">
            <MudPaper Class="pa-3 mb-2" Outlined="true">
                <MudRadio T="ExportFormat" Value="ExportFormat.Json" Color="Color.Primary">
                    <div class="d-flex align-center">
                        <MudIcon Icon="@Icons.Material.Filled.DataObject" Class="mr-2" />
                        <div>
                            <MudText Typo="Typo.body1">JSON Format</MudText>
                            <MudText Typo="Typo.caption" Color="Color.Secondary">
                                Standard format, good for programmatic use
                            </MudText>
                        </div>
                    </div>
                </MudRadio>
            </MudPaper>
            <MudPaper Class="pa-3 mb-2" Outlined="true">
                <MudRadio T="ExportFormat" Value="ExportFormat.Yaml" Color="Color.Primary">
                    <div class="d-flex align-center">
                        <MudIcon Icon="@Icons.Material.Filled.Description" Class="mr-2" />
                        <div>
                            <MudText Typo="Typo.body1">YAML Format</MudText>
                            <MudText Typo="Typo.caption" Color="Color.Secondary">
                                Human-readable, easy to edit manually
                            </MudText>
                        </div>
                    </div>
                </MudRadio>
            </MudPaper>
        </MudRadioGroup>

        <MudTextField @bind-Value="FileName"
                      Label="File Name"
                      Variant="Variant.Outlined"
                      Adornment="Adornment.End"
                      AdornmentText="@BlueprintSerializationService.GetFileExtension(SelectedFormat)"
                      Class="mt-4"
                      HelperText="The file will be downloaded to your default downloads folder" />

        @if (_exporting)
        {
            <MudProgressLinear Indeterminate="true" Color="Color.Primary" Class="mt-4" />
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="Cancel" Color="Color.Default" Disabled="@_exporting">Cancel</MudButton>
        <MudButton OnClick="Export"
                   Color="Color.Primary"
                   Variant="Variant.Filled"
                   Disabled="@(_exporting || string.IsNullOrWhiteSpace(FileName))"
                   StartIcon="@Icons.Material.Filled.Download">
            Export
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter]
    private IMudDialogInstance MudDialog { get; set; } = null!;

    [Inject]
    private BlueprintSerializationService SerializationService { get; set; } = null!;

    [Inject]
    private IJSRuntime JS { get; set; } = null!;

    [Inject]
    private ISnackbar Snackbar { get; set; } = null!;

    [Parameter]
    public Blueprint Blueprint { get; set; } = new();

    private ExportFormat SelectedFormat { get; set; } = ExportFormat.Json;
    private string FileName { get; set; } = string.Empty;
    private bool _exporting;

    protected override void OnInitialized()
    {
        // Generate default filename from blueprint title
        FileName = SanitizeFileName(Blueprint.Title);
    }

    private async Task Export()
    {
        _exporting = true;
        StateHasChanged();

        try
        {
            string content;
            string mimeType;

            if (SelectedFormat == ExportFormat.Json)
            {
                content = SerializationService.ToJson(Blueprint);
                mimeType = BlueprintSerializationService.GetMimeType(ExportFormat.Json);
            }
            else
            {
                content = SerializationService.ToYaml(Blueprint);
                mimeType = BlueprintSerializationService.GetMimeType(ExportFormat.Yaml);
            }

            var fullFileName = FileName + BlueprintSerializationService.GetFileExtension(SelectedFormat);

            // Download the file using JavaScript
            await DownloadFile(fullFileName, content, mimeType);

            Snackbar.Add($"Blueprint exported to {fullFileName}", Severity.Success);
            MudDialog.Close(DialogResult.Ok(fullFileName));
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Export failed: {ex.Message}", Severity.Error);
        }
        finally
        {
            _exporting = false;
            StateHasChanged();
        }
    }

    private async Task DownloadFile(string fileName, string content, string mimeType)
    {
        // Convert content to base64 for JavaScript download
        var bytes = System.Text.Encoding.UTF8.GetBytes(content);
        var base64 = Convert.ToBase64String(bytes);

        await JS.InvokeVoidAsync("downloadFile", fileName, base64, mimeType);
    }

    private void Cancel()
    {
        MudDialog.Cancel();
    }

    private static string SanitizeFileName(string name)
    {
        if (string.IsNullOrWhiteSpace(name))
            return "blueprint";

        // Remove invalid filename characters
        var invalid = Path.GetInvalidFileNameChars();
        var sanitized = new string(name
            .Replace(' ', '-')
            .Where(c => !invalid.Contains(c))
            .ToArray());

        return string.IsNullOrWhiteSpace(sanitized) ? "blueprint" : sanitized.ToLowerInvariant();
    }
}
