@* SPDX-License-Identifier: MIT *@
@* Copyright (c) 2026 Sorcha Contributors *@

@page "/my-actions"
@rendermode @(new InteractiveWebAssemblyRenderMode(prerender: false))
@attribute [Authorize]
@using Microsoft.AspNetCore.Authorization
@using MudBlazor
@using Sorcha.UI.Core.Models.Actions
@using Sorcha.UI.Core.Models.Registers
@using Sorcha.UI.Core.Models.Workflows
@using Sorcha.UI.Core.Components.Shared
@using Sorcha.UI.Core.Components.Workflows
@using Sorcha.UI.Core.Services
@inject IWorkflowService WorkflowService
@inject IWalletApiService WalletService
@inject ActionsHubConnection ActionsHub
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject ILogger<MyActions> Logger
@implements IAsyncDisposable

<PageTitle>My Pending Actions - Sorcha Platform</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraLarge" Class="mt-4">
    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-2">
        <MudStack Spacing="0">
            <MudText Typo="Typo.h4">
                <MudIcon Icon="@Icons.Material.Filled.Task" Class="mr-2" />
                My Pending Actions
            </MudText>
            <MudText Typo="Typo.body1" Color="Color.Secondary">
                Actions requiring your attention
            </MudText>
        </MudStack>

        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
            @* Real-time connection status indicator *@
            <MudChip T="string"
                     Size="Size.Small"
                     Color="@GetConnectionColor()"
                     Icon="@GetConnectionIcon()"
                     Variant="Variant.Outlined">
                @_connectionState.StatusText
            </MudChip>
            <MudButton Variant="Variant.Outlined" Color="Color.Primary" Size="Size.Small"
                       StartIcon="@Icons.Material.Filled.Refresh" OnClick="LoadActionsAsync">
                Refresh
            </MudButton>
        </MudStack>
    </MudStack>

    @* Real-time notifications banner *@
    @if (_recentNotifications.Count > 0)
    {
        <MudAlert Severity="Severity.Info" Class="mb-4" ShowCloseIcon="true" CloseIconClicked="ClearNotifications">
            <MudText Typo="Typo.body2">
                <strong>@_recentNotifications.Count new notification(s)</strong> received via real-time updates
            </MudText>
        </MudAlert>
    }

    @if (_serviceError)
    {
        <ServiceUnavailable ServiceName="Workflow Service" OnRetry="LoadActionsAsync" />
    }
    else if (_loading)
    {
        <MudGrid>
            @for (var i = 0; i < 3; i++)
            {
                <MudItem xs="12" md="6" lg="4">
                    <MudCard Elevation="2">
                        <MudCardContent>
                            <MudSkeleton Width="60%" Height="24px" Class="mb-2" />
                            <MudSkeleton Width="40%" Height="16px" Class="mb-3" />
                            <MudSkeleton Width="100%" Height="16px" />
                        </MudCardContent>
                    </MudCard>
                </MudItem>
            }
        </MudGrid>
    }
    else if (_actions.Count == 0)
    {
        <EmptyState Icon="@Icons.Material.Filled.CheckCircle"
                    Title="All Caught Up!"
                    Description="No pending actions require your attention." />
    }
    else
    {
        <MudGrid>
            @foreach (var action in _actions)
            {
                <MudItem xs="12" md="6" lg="4">
                    <MudCard Elevation="2">
                        <MudCardHeader>
                            <CardHeaderContent>
                                <MudText Typo="Typo.h6">@action.ActionName</MudText>
                                <MudText Typo="Typo.body2" Color="Color.Secondary">@action.BlueprintName</MudText>
                            </CardHeaderContent>
                            <CardHeaderActions>
                                <MudChip T="string" Size="Size.Small" Color="@GetPriorityColor(action.Priority)">@action.Priority</MudChip>
                            </CardHeaderActions>
                        </MudCardHeader>
                        <MudCardContent>
                            <MudText Typo="Typo.body2" Class="mb-2">@action.Description</MudText>
                            @if (!string.IsNullOrEmpty(action.InstanceId))
                            {
                                <div class="mb-1">
                                    <MudText Typo="Typo.caption" Color="Color.Secondary" Style="display: inline;">Instance: </MudText>
                                    <TruncatedId Value="@action.InstanceId" />
                                </div>
                            }
                            <MudDivider Class="my-2" />
                            <MudText Typo="Typo.caption" Color="Color.Secondary">
                                <MudIcon Icon="@Icons.Material.Filled.Schedule" Size="Size.Small" />
                                Assigned: @action.AssignedAt.ToString("MMM dd, yyyy HH:mm")
                            </MudText>
                            @if (action.DueAt.HasValue)
                            {
                                <MudText Typo="Typo.caption" Color="@(action.DueAt.Value < DateTimeOffset.Now ? Color.Error : Color.Secondary)">
                                    <MudIcon Icon="@Icons.Material.Filled.Timer" Size="Size.Small" />
                                    Due: @action.DueAt.Value.ToString("MMM dd, yyyy HH:mm")
                                </MudText>
                            }
                        </MudCardContent>
                        <MudCardActions>
                            <MudButton Color="Color.Primary" Variant="Variant.Filled" FullWidth="true"
                                       OnClick="() => TakeAction(action)">
                                Take Action
                            </MudButton>
                        </MudCardActions>
                    </MudCard>
                </MudItem>
            }
        </MudGrid>
    }

    <MudItem xs="12" Class="mt-4">
        <MudPaper Class="pa-4" Elevation="0" Outlined="true">
            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                <MudIcon Icon="@Icons.Material.Filled.Info" Color="Color.Info" />
                <MudText Typo="Typo.body2">
                    <strong>Real-time updates enabled.</strong>
                    New actions will appear automatically when they become available for your wallet.
                    @if (_connectionState.Status != ConnectionStatus.Connected)
                    {
                        <span class="ml-2" style="color: var(--mud-palette-warning);">
                            (Currently @_connectionState.StatusText.ToLower())
                        </span>
                    }
                </MudText>
            </MudStack>
        </MudPaper>
    </MudItem>
</MudContainer>

@code {
    private List<PendingActionViewModel> _actions = [];
    private List<ActionAvailableNotification> _recentNotifications = [];
    private ConnectionState _connectionState = new();
    private ActionsHubConnection? _actionsHub = null;
    private bool _loading = true;
    private bool _serviceError;

    protected override async Task OnInitializedAsync()
    {
        await LoadActionsAsync();
        await ConnectToActionsHubAsync();
    }

    private async Task ConnectToActionsHubAsync()
    {
        _actionsHub = ActionsHub;

        // Subscribe to events
        _actionsHub.OnConnectionStateChanged += HandleConnectionStateChanged;
        _actionsHub.OnActionAvailable += HandleActionAvailable;
        _actionsHub.OnActionConfirmed += HandleActionConfirmed;
        _actionsHub.OnActionRejected += HandleActionRejected;
        _actionsHub.OnWorkflowCompleted += HandleWorkflowCompleted;

        // Sync current state
        _connectionState = _actionsHub.ConnectionState;

        try
        {
            await _actionsHub.StartAsync();

            // Subscribe to user's wallet addresses for targeted notifications
            var wallets = await WalletService.GetWalletsAsync();
            foreach (var wallet in wallets)
            {
                await _actionsHub.SubscribeToWalletAsync(wallet.Address);
            }
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to connect to ActionsHub â€” page will use polling");
        }
    }

    private async Task LoadActionsAsync()
    {
        _loading = true;
        _serviceError = false;

        try
        {
            _actions = await WorkflowService.GetPendingActionsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading pending actions");
            _serviceError = true;
        }
        finally
        {
            _loading = false;
        }
    }

    private async Task TakeAction(PendingActionViewModel action)
    {
        var parameters = new DialogParameters
        {
            ["Action"] = action
        };
        var options = new DialogOptions { MaxWidth = MaxWidth.Medium, FullWidth = true };
        var dialog = await DialogService.ShowAsync<ActionForm>("Execute Action", parameters, options);
        var result = await dialog.Result;

        if (result is { Canceled: false })
        {
            Snackbar.Add("Action submitted successfully", Severity.Success);
            await LoadActionsAsync();
        }
    }

    private Color GetPriorityColor(string priority) => priority.ToLower() switch
    {
        "high" => Color.Error,
        "normal" => Color.Warning,
        "low" => Color.Info,
        _ => Color.Default
    };

    private void HandleConnectionStateChanged(ConnectionState state)
    {
        _connectionState = state;
        InvokeAsync(StateHasChanged);
    }

    private async Task HandleActionAvailable(ActionAvailableNotification notification)
    {
        _recentNotifications.Add(notification);
        Snackbar.Add($"New action available: {notification.ActionTitle}", Severity.Success);
        await LoadActionsAsync();
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleActionConfirmed(ActionNotification notification)
    {
        Snackbar.Add($"Action confirmed", Severity.Info);
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleActionRejected(ActionRejectedNotification notification)
    {
        Snackbar.Add($"Action was rejected: {notification.Reason}", Severity.Warning);
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleWorkflowCompleted(WorkflowCompletedNotification notification)
    {
        Snackbar.Add("Workflow completed", Severity.Success);
        await LoadActionsAsync();
        await InvokeAsync(StateHasChanged);
    }

    private void ClearNotifications()
    {
        _recentNotifications.Clear();
        StateHasChanged();
    }

    private Color GetConnectionColor() => _connectionState.Status switch
    {
        ConnectionStatus.Connected => Color.Success,
        ConnectionStatus.Connecting => Color.Info,
        ConnectionStatus.Reconnecting => Color.Warning,
        ConnectionStatus.Disconnected => Color.Error,
        _ => Color.Default
    };

    private string GetConnectionIcon() => _connectionState.Status switch
    {
        ConnectionStatus.Connected => Icons.Material.Filled.SignalCellularAlt,
        ConnectionStatus.Connecting => Icons.Material.Filled.Sync,
        ConnectionStatus.Reconnecting => Icons.Material.Filled.SyncProblem,
        ConnectionStatus.Disconnected => Icons.Material.Filled.SignalCellularOff,
        _ => Icons.Material.Filled.HelpOutline
    };

    public ValueTask DisposeAsync()
    {
        if (_actionsHub != null)
        {
            _actionsHub.OnConnectionStateChanged -= HandleConnectionStateChanged;
            _actionsHub.OnActionAvailable -= HandleActionAvailable;
            _actionsHub.OnActionConfirmed -= HandleActionConfirmed;
            _actionsHub.OnActionRejected -= HandleActionRejected;
            _actionsHub.OnWorkflowCompleted -= HandleWorkflowCompleted;
        }

        return ValueTask.CompletedTask;
    }
}
