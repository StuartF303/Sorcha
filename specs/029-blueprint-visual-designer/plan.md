# Implementation Plan: Blueprint Visual Designer

**Branch**: `029-blueprint-visual-designer` | **Date**: 2026-02-09 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/029-blueprint-visual-designer/spec.md`

## Summary

Create a readonly visual diagram component that renders blueprint JSON as an interactive flow diagram showing participants, actions, routes, and data flow. Reuse the existing Z.Blazor.Diagrams v3.0.4 library with locked nodes and a new `ReadOnlyActionNodeWidget`. Integrate the viewer into the Templates page (detail panel preview) and Blueprints page (dialog view). Also verify the end-to-end blueprint deployment pipeline (template → publish → instance creation).

## Technical Context

**Language/Version**: C# 13 / .NET 10
**Primary Dependencies**: Z.Blazor.Diagrams 3.0.4, MudBlazor, Blazor WASM
**Storage**: N/A (readonly viewer, consumes existing Blueprint Service API)
**Testing**: xUnit + FluentAssertions (layout algorithm), manual UI testing
**Target Platform**: Blazor WebAssembly (browser)
**Project Type**: Web (existing Sorcha.UI solution)
**Performance Goals**: Diagram renders within 2 seconds for blueprints with up to 20 actions
**Constraints**: No new JS dependencies, reuse existing diagram library, readonly only
**Scale/Scope**: 4 new Razor components, 1 layout service, modifications to 2 existing pages

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. Microservices-First | PASS | No new services — UI-only changes |
| II. Security First | PASS | Readonly viewer, no data mutation, uses existing auth |
| III. API Documentation | PASS | No new API endpoints |
| IV. Testing Requirements | PASS | Unit tests for layout algorithm, manual UI tests |
| V. Code Quality | PASS | C# 13, async/await, DI, nullable enabled |
| VI. Blueprint Standards | PASS | Consumes existing Blueprint JSON format |
| VII. Domain-Driven Design | PASS | Uses correct terminology (Blueprint, Action, Participant) |
| VIII. Observability | N/A | Client-side only, no backend telemetry needed |

**Post-Design Re-Check**: All gates pass. No new backend services, no new API endpoints, no new storage. Feature is entirely within existing UI projects.

## Project Structure

### Documentation (this feature)

```text
specs/029-blueprint-visual-designer/
├── plan.md              # This file
├── spec.md              # Feature specification
├── research.md          # Research decisions
├── data-model.md        # Data model (UI layout models)
├── quickstart.md        # Verification scenarios
├── contracts/
│   └── ui-components.md # Component interface contracts
├── checklists/
│   └── requirements.md  # Quality checklist
└── tasks.md             # Task list (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
src/Apps/Sorcha.UI/
├── Sorcha.UI.Core/
│   ├── Components/Designer/
│   │   ├── BlueprintViewerDiagram.razor       # NEW: Readonly diagram renderer
│   │   ├── ReadOnlyActionNodeWidget.razor     # NEW: Simplified node widget (no edit toolbar)
│   │   ├── ActionDetailPopover.razor          # NEW: Read-only detail on click
│   │   ├── BlueprintViewerDialog.razor        # NEW: Dialog wrapper for Blueprints page
│   │   ├── ActionNodeWidget.razor             # EXISTING: Unchanged
│   │   └── PropertiesPanel.razor              # EXISTING: Unchanged
│   ├── Models/Designer/
│   │   ├── DiagramLayout.cs                   # NEW: Layout result model
│   │   ├── DiagramNode.cs                     # NEW: Positioned node
│   │   ├── DiagramEdge.cs                     # NEW: Route edge
│   │   ├── ActionNodeModel.cs                 # EXISTING: Unchanged
│   │   └── ParticipantNodeModel.cs            # EXISTING: Unchanged
│   └── Services/
│       ├── BlueprintLayoutService.cs          # NEW: Auto-layout algorithm
│       ├── IBlueprintApiService.cs            # MODIFIED: Add GetBlueprintDetailAsync
│       ├── BlueprintApiService.cs             # MODIFIED: Implement GetBlueprintDetailAsync
│       └── ITemplateApiService.cs             # EXISTING: Unchanged (EvaluateTemplateAsync suffices)
└── Sorcha.UI.Web.Client/
    └── Pages/
        ├── Templates.razor                    # MODIFIED: Add diagram to detail panel
        └── Blueprints.razor                   # MODIFIED: Add "View" button + dialog

tests/
└── Sorcha.UI.Core.Tests/                      # Layout service unit tests (if test project exists)
```

**Structure Decision**: All changes within existing `Sorcha.UI.Core` and `Sorcha.UI.Web.Client` projects. No new projects needed. New components in `Components/Designer/` alongside existing designer components. New models in `Models/Designer/` alongside existing node models. Layout service in `Services/` alongside existing API services.

## Complexity Tracking

No constitution violations to justify. All changes are within existing project structure with no new services, storage, or external dependencies.

## Key Design Decisions

### 1. Separate Viewer Component (Not Conditional in Designer)

The existing `Designer.razor` is 850 lines with editing logic, LocalStorage persistence, toolbar, and Properties Panel. Rather than adding conditional `isReadOnly` branches, create a dedicated `BlueprintViewerDiagram.razor` that:
- Accepts a `Blueprint` parameter
- Internally creates a `BlazorDiagram` with all nodes locked
- Registers `ReadOnlyActionNodeWidget` (no edit buttons)
- Runs auto-layout algorithm
- Supports zoom but prevents editing

### 2. Auto-Layout Algorithm (Simplified Sugiyama)

Layout steps:
1. Build adjacency graph from `Action.routes[].nextActionIds`
2. Identify starting actions (`isStartingAction == true`)
3. BFS from starting actions to assign layer depths
4. Detect back-edges (cycles) — assign target to earlier layer
5. Order nodes within layers to minimise crossings
6. Assign coordinates: `y = layer * 180px`, `x = orderInLayer * 320px`
7. Generate edges with visual types

### 3. Template Preview via Evaluation

For parameterised templates, the viewer evaluates with default parameters to produce a preview blueprint. The `ITemplateApiService.EvaluateTemplateAsync()` method already returns a full `Blueprint` object.

For simple templates (like ping-pong), the template JSON embeds the blueprint directly — parse it client-side.

### 4. Blueprint Detail API Extension

Add `GetBlueprintDetailAsync(id)` to `IBlueprintApiService` that returns the full `Blueprint` domain model (not just the summary ViewModel). Uses the same `GET /api/blueprints/{id}` endpoint but deserialises the full response.

## Implementation Phases

### Phase 1: Core Viewer Component (US1)
- Layout models (DiagramLayout, DiagramNode, DiagramEdge)
- BlueprintLayoutService (auto-layout algorithm)
- ReadOnlyActionNodeWidget (simplified node rendering)
- BlueprintViewerDiagram (main readonly diagram component)
- Unit tests for layout algorithm

### Phase 2: Template Integration (US2)
- Modify Templates.razor detail panel to include diagram preview
- Handle simple vs parameterised template evaluation for preview
- Loading state while evaluating template

### Phase 3: Blueprint Library Integration (US3)
- Add GetBlueprintDetailAsync to IBlueprintApiService
- BlueprintViewerDialog component
- Modify Blueprints.razor to add "View" button
- ActionDetailPopover for node click details

### Phase 4: Deployment Verification (US4)
- Walk through end-to-end pipeline: template → evaluate → save → publish → instance
- Verify cycle warnings display correctly
- Document any issues found

### Phase 5: Polish
- Participant colour legend
- Edge visual refinements (labels, styles)
- Large blueprint testing (supply-chain template)
- Cross-browser verification
